package de.cebitec.mgx.gui.wizard.habitat;

import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Point2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.net.URL;
import java.text.DecimalFormat;
import java.util.HashSet;
import java.util.Set;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import org.jdesktop.swingx.JXMapKit;
import org.jdesktop.swingx.JXMapKit.DefaultProviders;
import org.jdesktop.swingx.mapviewer.DefaultTileFactory;
import org.jdesktop.swingx.mapviewer.GeoPosition;
import org.jdesktop.swingx.mapviewer.TileFactory;
import org.jdesktop.swingx.mapviewer.TileFactoryInfo;
import org.jdesktop.swingx.mapviewer.Waypoint;
import org.jdesktop.swingx.mapviewer.WaypointPainter;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

public final class HabitatWizardVisualPanel1 extends JPanel implements DocumentListener {

    public static final String PROP_ALTITUDE = "altitude";
    public static final String PROP_LOCATION = "location";
    // max number of results
    private static final int LIST_SIZE_LOCATIONS = 10;
    private Location[] foundLocations;
    private Set<Waypoint> waypoints;

    /** Creates new form mzWizardVisualPanel1 */
    public HabitatWizardVisualPanel1() {
        initComponents();
        initMapKit();
        initMashup();
        height.getDocument().addDocumentListener(this);
        geoPos.getDocument().addDocumentListener(this);
        geoPos.setEditable(false);
    }

    @Override
    public String getName() {
        return "Geographical location";
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField_searchLoc = new javax.swing.JTextField();
        jXMapKit1 = new org.jdesktop.swingx.JXMapKit();
        jLabel_mapCenterPos = new javax.swing.JLabel();
        jLabel_inputHeight = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jList_foundLocations = new javax.swing.JList();
        jButton_searchLoc = new javax.swing.JButton();
        jLabel_foundLocations = new javax.swing.JLabel();
        jLabel_searchLoc = new javax.swing.JLabel();
        height = new javax.swing.JTextField();
        geoPos = new javax.swing.JTextField();

        jTextField_searchLoc.setText(org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "habitatVisualPanel1.jTextField_searchLoc.text")); // NOI18N
        jTextField_searchLoc.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField_searchLocActionPerformed(evt);
            }
        });

        jXMapKit1.setDefaultProvider(org.jdesktop.swingx.JXMapKit.DefaultProviders.OpenStreetMaps);
        jXMapKit1.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                jXMapKit1PropertyChange(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel_mapCenterPos, org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "habitatVisualPanel1.jLabel_mapCenterPos.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel_inputHeight, org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "habitatVisualPanel1.jLabel_inputHeight.text")); // NOI18N

        jList_foundLocations.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane2.setViewportView(jList_foundLocations);

        org.openide.awt.Mnemonics.setLocalizedText(jButton_searchLoc, org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "habitatVisualPanel1.jButton_searchLoc.text")); // NOI18N
        jButton_searchLoc.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton_searchLocActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel_foundLocations, org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "habitatVisualPanel1.jLabel_foundLocations.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel_searchLoc, org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "habitatVisualPanel1.jLabel_searchLoc.text")); // NOI18N

        height.setText(org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "habitatVisualPanel1.jTextField_inputHeight.text")); // NOI18N

        geoPos.setText(org.openide.util.NbBundle.getMessage(HabitatWizardVisualPanel1.class, "HabitatWizardVisualPanel1.geoPos.text")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jXMapKit1, javax.swing.GroupLayout.PREFERRED_SIZE, 374, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 102, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel_mapCenterPos)
                            .addComponent(jLabel_inputHeight))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(height, javax.swing.GroupLayout.DEFAULT_SIZE, 103, Short.MAX_VALUE)
                            .addComponent(geoPos))))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 169, Short.MAX_VALUE)
                    .addComponent(jButton_searchLoc, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 169, Short.MAX_VALUE)
                    .addComponent(jTextField_searchLoc, javax.swing.GroupLayout.DEFAULT_SIZE, 169, Short.MAX_VALUE)
                    .addComponent(jLabel_searchLoc)
                    .addComponent(jLabel_foundLocations))
                .addGap(25, 25, 25))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel_searchLoc)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField_searchLoc, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton_searchLoc)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel_foundLocations)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 207, Short.MAX_VALUE))
                    .addComponent(jXMapKit1, javax.swing.GroupLayout.PREFERRED_SIZE, 317, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel_mapCenterPos, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(geoPos, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(9, 9, 9)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(height, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel_inputHeight))
                .addContainerGap(18, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jXMapKit1PropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_jXMapKit1PropertyChange
        // TODO add your handling code here:
}//GEN-LAST:event_jXMapKit1PropertyChange

    private void jButton_searchLocActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton_searchLocActionPerformed
        searchLocation(jTextField_searchLoc.getText());
    }//GEN-LAST:event_jButton_searchLocActionPerformed

    private void jTextField_searchLocActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField_searchLocActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField_searchLocActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField geoPos;
    private javax.swing.JTextField height;
    private javax.swing.JButton jButton_searchLoc;
    private javax.swing.JLabel jLabel_foundLocations;
    private javax.swing.JLabel jLabel_inputHeight;
    private javax.swing.JLabel jLabel_mapCenterPos;
    private javax.swing.JLabel jLabel_searchLoc;
    private javax.swing.JList jList_foundLocations;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField jTextField_searchLoc;
    private org.jdesktop.swingx.JXMapKit jXMapKit1;
    // End of variables declaration//GEN-END:variables


    private void initMapKit() {
        final JXMapKit kit = jXMapKit1;
        MouseListener[] ml2 = kit.getMainMap().getMouseListeners();
        MouseMotionListener[] mml2 = kit.getMainMap().getMouseMotionListeners();
        for (MouseListener mouseListener : ml2) {
            kit.removeMouseListener(mouseListener);
        }
        for (MouseMotionListener mouseMotionListener : mml2) {
            kit.removeMouseMotionListener(mouseMotionListener);
        }
        MouseListener[] ml = kit.getMiniMap().getMouseListeners();
        MouseMotionListener[] mml = kit.getMiniMap().getMouseMotionListeners();
        for (MouseListener mouseListener : ml) {
            kit.removeMouseListener(mouseListener);
        }
        for (MouseMotionListener mouseMotionListener : mml) {
            kit.removeMouseMotionListener(mouseMotionListener);
        }

        kit.setDefaultProvider(DefaultProviders.OpenStreetMaps);
        kit.getMainMap().addPropertyChangeListener("centerPosition", new PropertyChangeListener() {

            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                DecimalFormat twoPlaces = new DecimalFormat("0.00");

                String tmpText = twoPlaces.format(((GeoPosition) evt.getNewValue()).getLatitude()) + " | "
                        + twoPlaces.format(((GeoPosition) evt.getNewValue()).getLongitude());
                geoPos.setText(tmpText);
            }
        });
        final int max = 17;
        TileFactoryInfo info = new TileFactoryInfo(1, max - 2, max,
                256, true, true, // tile size is 256 and x/y orientation is normal
                "http://tile.openstreetmap.org",//5/15/10.png",
                "x", "y", "z") {

            @Override
            public String getTileUrl(int x, int y, int zoom) {
                zoom = max - zoom;
                String url = this.baseURL + "/" + zoom + "/" + x + "/" + y + ".png";
                return url;
            }
        };
        TileFactory tf = new DefaultTileFactory(info);

        kit.setTileFactory(tf);
        kit.getMainMap().setZoom(15);
        kit.getMiniMap().setZoom(10);
        kit.setAddressLocation(new GeoPosition(51.5, 0));
        kit.getMainMap().setDrawTileBorders(true);
        kit.getMainMap().setRestrictOutsidePanning(true);
        kit.getMainMap().setRecenterOnClickEnabled(true);
        ((DefaultTileFactory) kit.getMainMap().getTileFactory()).setThreadPoolSize(8);
        waypoints = new HashSet<Waypoint>();
        waypoints.add(new Waypoint(kit.getMainMap().getCenterPosition()));
        WaypointPainter painter = new WaypointPainter();
        painter.setWaypoints(waypoints);
        kit.getMainMap().setOverlayPainter(painter);
        waypoints.clear();
        kit.getMainMap().addPropertyChangeListener("centerPosition", new PropertyChangeListener() {
            //listener to redraw waypoint in middle and to listen for invalid positions (bug in mapviwer)

            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                //bugfix to get no invalid data
                double lon = kit.getMainMap().getCenterPosition().getLongitude();
                if (lon > 180) {
                    lon = lon - 360;
                } else if (lon < -180) {
                    lon = lon + 360;
                }
                kit.setCenterPosition(new GeoPosition(((GeoPosition) evt.getNewValue()).getLatitude(), lon));
                kit.getMainMap().setCenterPosition(kit.getCenterPosition());
                Point2D pt = kit.getMiniMap().getTileFactory().geoToPixel(kit.getMainMap().getCenterPosition(), kit.getMiniMap().getZoom());
                waypoints.clear();
                waypoints.add(new Waypoint(kit.getMainMap().getCenterPosition()));
                kit.getMiniMap().setCenter(pt);
                kit.getMiniMap().repaint();
            }
        });
        kit.getMainMap().setCenterPosition(new GeoPosition(51.5, 0));
        waypoints.add(new Waypoint(kit.getMainMap().getCenterPosition()));
    }

    //search by name for geolocation and put them into selectionList
    private void searchLocation(String loc) {
        try {
            // FIXME - username?
            URL url = new URL("http://api.geonames.org/search?q=" + loc + "&featureClass=P&maxRows=" + LIST_SIZE_LOCATIONS + "&username=habitatwizard");
            XPath xpath = XPathFactory.newInstance().newXPath();
            NodeList list = (NodeList) xpath.evaluate("//geoname",
                    new InputSource(url.openStream()),
                    XPathConstants.NODESET);
            final String[] strings = new String[list.getLength()];
            for (int i = 0; i < list.getLength(); i++) {
                Node node = list.item(i);
                String title = (String) xpath.evaluate("name/text()",
                        node, XPathConstants.STRING);
                String country = (String) xpath.evaluate("countryCode/text()",
                        node, XPathConstants.STRING);
                Double lat = (Double) xpath.evaluate("lat/text()",
                        node, XPathConstants.NUMBER);
                Double lon = (Double) xpath.evaluate("lng/text()",
                        node, XPathConstants.NUMBER);
                strings[i] = title + "/" + country;
                foundLocations[i] = new Location(new GeoPosition(lat, lon), title + "/" + country);
            }

            // update result list
            jList_foundLocations.setModel(new javax.swing.AbstractListModel() {

                @Override
                public int getSize() {
                    return strings.length;
                }

                @Override
                public Object getElementAt(int i) {
                    return strings[i];
                }
            });

        } catch (Exception ex) {
        }
    }

    // listener on selectionList to change mapcenter and zoomlevel
    private void initMashup() {
        foundLocations = new Location[LIST_SIZE_LOCATIONS];
        jList_foundLocations.addListSelectionListener(new ListSelectionListener() {

            @Override
            public void valueChanged(ListSelectionEvent e) {
                int index = ((JList) e.getSource()).getSelectedIndex();
                jXMapKit1.setCenterPosition(foundLocations[index].getGeoLoc());
                jXMapKit1.setZoom(8);
            }
        });
    }

    public String getSelectedLocation() {
        GeoPosition pos = jXMapKit1.getAddressLocation();  // FIXME - check if this is correct
        Double latitude = pos.getLatitude();
        Double longitude = pos.getLongitude();
        return new StringBuilder(latitude.toString()).append(" ").append(longitude.toString()).toString();
    }

    /**
     * @return geographical height
     */
    public Long getAltitude() {
        return Long.parseLong(height.getText());
    }

    @Override
    public void changedUpdate(DocumentEvent e) {
        if (height.getDocument() == e.getDocument())
            firePropertyChange(PROP_ALTITUDE, 0, 1);
        if (geoPos.getDocument() == e.getDocument())
            firePropertyChange(PROP_LOCATION, 0, 1);
    }

    @Override
    public void insertUpdate(DocumentEvent e) {
    }

    @Override
    public void removeUpdate(DocumentEvent e) {
    }
}
