/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.cebitec.mgx.gui.report.ui;

import de.cebitec.mgx.api.exception.MGXException;
import de.cebitec.mgx.api.misc.DistributionI;
import de.cebitec.mgx.api.model.AttributeI;
import de.cebitec.mgx.api.model.AttributeTypeI;
import de.cebitec.mgx.api.model.JobI;
import de.cebitec.mgx.api.model.ModelBaseI;
import de.cebitec.mgx.api.model.SeqRunI;
import de.cebitec.mgx.api.model.qc.QCResultI;
import de.cebitec.mgx.api.model.tree.NodeI;
import de.cebitec.mgx.api.model.tree.TreeI;
import de.cebitec.mgx.common.JobState;
import de.cebitec.mgx.gui.qcmon.QCTopComponent;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;
import java.text.NumberFormat;
import java.util.Arrays;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.DoubleStream;
import javax.swing.SwingWorker;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.PieChart;
import org.knowm.xchart.PieChartBuilder;
import org.knowm.xchart.XChartPanel;
import org.knowm.xchart.style.PieStyler;
import org.knowm.xchart.style.PieStyler.AnnotationType;
import org.knowm.xchart.style.Styler.ChartTheme;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.awt.ActionReferences;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.LookupEvent;
import org.openide.util.LookupListener;
import org.openide.util.Utilities;
import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
import org.openide.windows.TopComponent;

/**
 * â€š
 * Top component which displays something.
 */
@ConvertAsProperties(
        dtd = "-//de.cebitec.mgx.gui.mgx_report//ReportSummary//EN",
        autostore = false
)
@TopComponent.Description(
        preferredID = "ReportSummaryTopComponent",
        iconBase = "de/cebitec/mgx/gui/reportcom/report.svg",
        persistenceType = TopComponent.PERSISTENCE_NEVER)
@TopComponent.Registration(mode = "editor", openAtStartup = false)
@ActionID(category = "Window", id = "de.cebitec.mgx.gui.mgx_report.ReportSummaryTopComponent")
@ActionReferences({
    @ActionReference(path = "Menu/Window", position = 550)
})
@TopComponent.OpenActionRegistration(
        displayName = "Show Report",
        preferredID = "ReportSummaryTopComponent"
)

public final class ReportSummaryTopComponent extends TopComponent implements LookupListener, PropertyChangeListener {

    private final Lookup.Result<SeqRunI> resultSeqRun;
    private SeqRunI currentSeqRun = null;

    private final InstanceContent content = new InstanceContent();
    private final Lookup lookup;
    private int tabIdx = -1;

    public ReportSummaryTopComponent() {
        initComponents();
        super.setName("ShowReport");
        super.setToolTipText("Show Report");

        lookup = new AbstractLookup(content);
        associateLookup(lookup);
        resultSeqRun = Utilities.actionsGlobalContext().lookupResult(SeqRunI.class);
        update();
        tabbedpane.addChangeListener((ChangeEvent e) -> {
            int newIdx = tabbedpane.getSelectedIndex();
            if (newIdx != tabIdx) {
                content.set(Collections.emptyList(), null);
                tabbedpane.getSelectedComponent();
                tabIdx = newIdx;
            }
        });

    }

    private static ReportSummaryTopComponent instance = null;

    public static ReportSummaryTopComponent getDefault() {
        if (instance == null) {
            instance = new ReportSummaryTopComponent();
        }
        return instance;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField1 = new javax.swing.JTextField();
        jFrame1 = new javax.swing.JFrame();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tabbedpane = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        z = new javax.swing.JLabel();
        nameseq = new javax.swing.JTextField();
        z1 = new javax.swing.JLabel();
        seqid = new javax.swing.JTextField();
        filler1 = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(32767, 0));
        z2 = new javax.swing.JLabel();
        seqcount = new javax.swing.JTextField();
        z3 = new javax.swing.JLabel();
        seqmeth = new javax.swing.JTextField();
        z4 = new javax.swing.JLabel();
        seqtech = new javax.swing.JTextField();
        z5 = new javax.swing.JLabel();
        paired = new javax.swing.JTextField();
        qccontroll = new javax.swing.JTabbedPane();
        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        jobLabel = new javax.swing.JLabel();
        phylumchart = new PieChartBuilder().width(700).height(500).theme(ChartTheme.GGPlot2).build();
        phylumchart.setTitle("Phylum");
        phylumpanel = new XChartPanel<>(phylumchart);
        classchart = new PieChartBuilder().width(700).height(500).theme(ChartTheme.GGPlot2).build();
        classchart.setTitle("Class");
        classpanel = new XChartPanel<>(classchart);
        kingdomchart = new PieChartBuilder().width(700).height(500).theme(ChartTheme.GGPlot2).build();
        kingdomchart.setTitle("Kingdom");
        kingdompanel = new XChartPanel<>(kingdomchart);
        orderchart = new PieChartBuilder().width(700).height(500).theme(ChartTheme.GGPlot2).build();
        orderchart.setTitle("Order");
        orderpanel = new XChartPanel<>(orderchart);
        familychart = new PieChartBuilder().width(700).height(500).theme(ChartTheme.GGPlot2).build();
        familychart.setTitle("Family");
        familypanel = new XChartPanel<>(familychart);
        genuschart = new PieChartBuilder().width(700).height(500).theme(ChartTheme.GGPlot2).build();
        genuschart.setTitle("Genus");
        genuspanel = new XChartPanel<>(genuschart);
        organismchart = new PieChartBuilder().width(700).height(500).theme(ChartTheme.GGPlot2).build();
        organismchart.setTitle("Organism");
        organismpanel = new XChartPanel<>(organismchart);
        jPanel3 = new javax.swing.JPanel();
        jobLabel1 = new javax.swing.JLabel();
        cogchart = new CategoryChartBuilder().width(1300).height(800).theme(ChartTheme.GGPlot2).build();
        cogchart.setTitle("TopTen COG-Gruppen");
        cogpanel = new XChartPanel<>(cogchart);
        funcchart = new CategoryChartBuilder().width(1300).height(1100).theme(ChartTheme.GGPlot2).build();
        funcchart.setTitle("Functional");
        funcpanel = new XChartPanel<>(funcchart);

        jTextField1.setText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jTextField1.text")); // NOI18N

        javax.swing.GroupLayout jFrame1Layout = new javax.swing.GroupLayout(jFrame1.getContentPane());
        jFrame1.getContentPane().setLayout(jFrame1Layout);
        jFrame1Layout.setHorizontalGroup(
            jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        jFrame1Layout.setVerticalGroup(
            jFrame1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jLabel2.text")); // NOI18N

        try
        {
            UIManager.setLookAndFeel( UIManager.getSystemLookAndFeelClassName() );
            UIManager.setLookAndFeel( "com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel" );
        }
        catch ( Exception e )
        {
            e.printStackTrace();
        }
        tabbedpane.setPreferredSize(new java.awt.Dimension(1400, 2300));

        jPanel1.setLayout(new FlowLayout());
        jPanel1.setBackground(new java.awt.Color(255, 255, 255));
        jPanel1.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jPanel1.toolTipText")); // NOI18N
        jPanel1.setPreferredSize(new java.awt.Dimension(1980, 1200));

        z.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(z, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.z.text")); // NOI18N
        z.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.z.toolTipText")); // NOI18N

        nameseq.setEditable(false);
        nameseq.setFont(new java.awt.Font("Avenir Next Condensed", 0, 18)); // NOI18N
        nameseq.setText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.nameseq.text")); // NOI18N
        nameseq.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.nameseq.toolTipText")); // NOI18N
        nameseq.setBorder(null);

        z1.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(z1, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.z1.text")); // NOI18N

        seqid.setFont(new java.awt.Font("Avenir Next Condensed", 0, 18)); // NOI18N
        seqid.setText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqid.text")); // NOI18N
        seqid.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqid.toolTipText")); // NOI18N
        seqid.setBorder(null);

        z2.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(z2, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.z2.text")); // NOI18N

        seqcount.setEditable(false);
        seqcount.setFont(new java.awt.Font("Avenir Next Condensed", 0, 18)); // NOI18N
        seqcount.setText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqcount.text")); // NOI18N
        seqcount.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqcount.toolTipText")); // NOI18N
        seqcount.setBorder(null);

        z3.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(z3, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.z3.text")); // NOI18N

        seqmeth.setEditable(false);
        seqmeth.setFont(new java.awt.Font("Avenir Next Condensed", 0, 18)); // NOI18N
        seqmeth.setText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqmeth.text")); // NOI18N
        seqmeth.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqmeth.toolTipText")); // NOI18N
        seqmeth.setBorder(null);

        z4.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(z4, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.z4.text")); // NOI18N

        seqtech.setEditable(false);
        seqtech.setFont(new java.awt.Font("Avenir Next Condensed", 0, 18)); // NOI18N
        seqtech.setText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqtech.text")); // NOI18N
        seqtech.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.seqtech.toolTipText")); // NOI18N
        seqtech.setBorder(null);

        z5.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(z5, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.z5.text")); // NOI18N

        paired.setEditable(false);
        paired.setFont(new java.awt.Font("Avenir Next Condensed", 0, 18)); // NOI18N
        paired.setText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.paired.text")); // NOI18N
        paired.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.paired.toolTipText")); // NOI18N
        paired.setBorder(null);

        jLabel1.setFont(new java.awt.Font("Avenir Next Condensed", 1, 24)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jLabel1.text")); // NOI18N

        jLabel3.setFont(new java.awt.Font("Avenir Next Condensed", 1, 24)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jLabel3.text")); // NOI18N

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(23, 23, 23)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(246, 246, 246)
                                .addComponent(filler1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addComponent(qccontroll)
                                .addGap(94, 94, 94))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(452, 452, 452)
                                .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGap(711, 711, 711))
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(z, javax.swing.GroupLayout.PREFERRED_SIZE, 340, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(z1, javax.swing.GroupLayout.PREFERRED_SIZE, 340, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(z2, javax.swing.GroupLayout.PREFERRED_SIZE, 340, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(z5, javax.swing.GroupLayout.PREFERRED_SIZE, 340, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(z4, javax.swing.GroupLayout.PREFERRED_SIZE, 340, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(z3, javax.swing.GroupLayout.PREFERRED_SIZE, 340, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(135, 135, 135)
                                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(seqmeth)
                                    .addComponent(seqtech)
                                    .addComponent(seqcount)
                                    .addComponent(nameseq)
                                    .addComponent(seqid)
                                    .addComponent(paired))
                                .addGap(528, 528, 528))))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(474, 474, 474)
                        .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(800, 800, 800)))
                .addGap(218, 218, 218))
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {z, z1, z2, z3, z4, z5});

        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 26, Short.MAX_VALUE)
                        .addGap(33, 33, 33)
                        .addComponent(nameseq))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGap(94, 94, 94)
                        .addComponent(z, javax.swing.GroupLayout.DEFAULT_SIZE, 37, Short.MAX_VALUE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(seqid)
                    .addComponent(z1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(seqcount)
                    .addComponent(z2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(seqmeth)
                    .addComponent(z3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(6, 6, 6)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(seqtech)
                    .addComponent(z4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(paired)
                    .addComponent(z5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(48, 48, 48)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 26, Short.MAX_VALUE)
                .addGap(47, 47, 47)
                .addComponent(qccontroll, javax.swing.GroupLayout.DEFAULT_SIZE, 391, Short.MAX_VALUE)
                .addGap(732, 732, 732)
                .addComponent(filler1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(732, 732, 732))
        );

        tabbedpane.addTab(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jPanel1.TabConstraints.tabTitle"), jPanel1); // NOI18N
        jPanel1.getAccessibleContext().setAccessibleDescription(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jPanel1.AccessibleContext.accessibleDescription")); // NOI18N

        jPanel2.setLayout(new FlowLayout(FlowLayout.LEFT));
        jPanel2.setBackground(new java.awt.Color(255, 255, 255));
        jPanel2.setAutoscrolls(true);
        jPanel2.setRequestFocusEnabled(false);

        jobLabel.setBackground(new java.awt.Color(255, 255, 255));
        jobLabel.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jobLabel, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jobLabel.text")); // NOI18N

        phylumpanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        phylumpanel.setPreferredSize(new java.awt.Dimension(700, 500));

        javax.swing.GroupLayout phylumpanelLayout = new javax.swing.GroupLayout(phylumpanel);
        phylumpanel.setLayout(phylumpanelLayout);
        phylumpanelLayout.setHorizontalGroup(
            phylumpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        phylumpanelLayout.setVerticalGroup(
            phylumpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        classpanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        classpanel.setPreferredSize(new java.awt.Dimension(700, 500));

        javax.swing.GroupLayout classpanelLayout = new javax.swing.GroupLayout(classpanel);
        classpanel.setLayout(classpanelLayout);
        classpanelLayout.setHorizontalGroup(
            classpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        classpanelLayout.setVerticalGroup(
            classpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 481, Short.MAX_VALUE)
        );

        kingdompanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        kingdompanel.setPreferredSize(new java.awt.Dimension(700, 500));
        kingdompanel.setRequestFocusEnabled(false);

        orderpanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        orderpanel.setPreferredSize(new java.awt.Dimension(700, 500));

        javax.swing.GroupLayout orderpanelLayout = new javax.swing.GroupLayout(orderpanel);
        orderpanel.setLayout(orderpanelLayout);
        orderpanelLayout.setHorizontalGroup(
            orderpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        orderpanelLayout.setVerticalGroup(
            orderpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        familypanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        familypanel.setPreferredSize(new java.awt.Dimension(700, 500));

        genuspanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        genuspanel.setPreferredSize(new java.awt.Dimension(700, 500));

        organismpanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        organismpanel.setPreferredSize(new java.awt.Dimension(700, 500));

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(classpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 732, Short.MAX_VALUE)
                            .addComponent(kingdompanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(familypanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGap(26, 26, 26)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(phylumpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 732, Short.MAX_VALUE)
                            .addComponent(orderpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 732, Short.MAX_VALUE)
                            .addComponent(genuspanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(574, 574, 574)
                        .addComponent(jobLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(541, 541, 541))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(402, 402, 402)
                        .addComponent(organismpanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(360, 360, 360)))
                .addGap(28, 28, 28))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(45, 45, 45)
                .addComponent(jobLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 52, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(kingdompanel, javax.swing.GroupLayout.DEFAULT_SIZE, 492, Short.MAX_VALUE)
                    .addComponent(phylumpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 492, Short.MAX_VALUE))
                .addGap(29, 29, 29)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(classpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 481, Short.MAX_VALUE)
                    .addComponent(orderpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 481, Short.MAX_VALUE))
                .addGap(26, 26, 26)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(familypanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(genuspanel, javax.swing.GroupLayout.DEFAULT_SIZE, 492, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(organismpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 492, Short.MAX_VALUE)
                .addGap(132, 132, 132))
        );

        jobLabel.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jobLabel.AccessibleContext.accessibleName")); // NOI18N

        tabbedpane.addTab(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jPanel2.TabConstraints.tabTitle"), jPanel2); // NOI18N

        jPanel3.setBackground(new java.awt.Color(255, 255, 255));
        jPanel3.setToolTipText(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jPanel3.toolTipText")); // NOI18N

        jobLabel1.setBackground(new java.awt.Color(255, 255, 255));
        jobLabel1.setFont(new java.awt.Font("Avenir Next Condensed", 1, 18)); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jobLabel1, org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jobLabel1.text")); // NOI18N
        jobLabel1.setVerticalAlignment(javax.swing.SwingConstants.TOP);

        cogpanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        cogpanel.setPreferredSize(new java.awt.Dimension(1300, 800));
        cogpanel.setRequestFocusEnabled(false);

        funcpanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        funcpanel.setPreferredSize(new java.awt.Dimension(1300, 1100));
        funcpanel.setRequestFocusEnabled(false);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(514, 514, 514)
                .addComponent(jobLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(629, 629, 629))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(47, 47, 47)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(funcpanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(cogpanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(143, 143, 143))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(37, 37, 37)
                .addComponent(jobLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(cogpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 437, Short.MAX_VALUE)
                .addGap(138, 138, 138)
                .addComponent(funcpanel, javax.swing.GroupLayout.DEFAULT_SIZE, 878, Short.MAX_VALUE)
                .addGap(750, 750, 750))
        );

        tabbedpane.addTab(org.openide.util.NbBundle.getMessage(ReportSummaryTopComponent.class, "ReportSummaryTopComponent.jPanel3.TabConstraints.tabTitle"), jPanel3); // NOI18N

        jScrollPane1.setViewportView(tabbedpane);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 1496, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel classpanel;
    PieChart classchart;
    private javax.swing.JPanel cogpanel;
    CategoryChart cogchart;
    private javax.swing.JPanel familypanel;
    PieChart familychart;
    private javax.swing.Box.Filler filler1;
    private javax.swing.JPanel funcpanel;
    CategoryChart funcchart;
    private javax.swing.JPanel genuspanel;
    PieChart genuschart;
    private javax.swing.JFrame jFrame1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JLabel jobLabel;
    private javax.swing.JLabel jobLabel1;
    private javax.swing.JPanel kingdompanel;
    PieChart kingdomchart;
    private javax.swing.JTextField nameseq;
    private javax.swing.JPanel orderpanel;
    PieChart orderchart;
    private javax.swing.JPanel organismpanel;
    PieChart organismchart;
    private javax.swing.JTextField paired;
    private javax.swing.JPanel phylumpanel;
    PieChart phylumchart;
    private javax.swing.JTabbedPane qccontroll;
    private javax.swing.JTextField seqcount;
    private javax.swing.JTextField seqid;
    private javax.swing.JTextField seqmeth;
    private javax.swing.JTextField seqtech;
    private javax.swing.JTabbedPane tabbedpane;
    private javax.swing.JLabel z;
    private javax.swing.JLabel z1;
    private javax.swing.JLabel z2;
    private javax.swing.JLabel z3;
    private javax.swing.JLabel z4;
    private javax.swing.JLabel z5;
    // End of variables declaration//GEN-END:variables
    @Override
    public void componentOpened() {
        resultSeqRun.addLookupListener(this);
        update();
    }

    @Override
    public void componentClosed() {
        resultSeqRun.removeLookupListener(this);
    }

    void writeProperties(java.util.Properties p) {
        p.setProperty("version", "1.0");

    }

    void readProperties(java.util.Properties p) {
        String version = p.getProperty("version");
    }

    private void update() {
        SeqRunI prevRun = currentSeqRun;

        for (SeqRunI run : resultSeqRun.allInstances()) {
            if (currentSeqRun == null || !run.equals(currentSeqRun)) {
                currentSeqRun = run;
                break;
            }
        }

        if (currentSeqRun == null || currentSeqRun.equals(prevRun)) {
            return;
        }

        if (prevRun != null) {
            prevRun.removePropertyChangeListener(this);
        }
        currentSeqRun.addPropertyChangeListener(this);

        SwingWorker<List<SeqRunI>, Void> worker;
        worker = new SwingWorker<List<SeqRunI>, Void>() {
            List<DistributionI> attypes;

            @Override
            protected List<SeqRunI> doInBackground() throws Exception {
                List<SeqRunI> seqlist = new ArrayList<>();
                seqlist.add(currentSeqRun);
                return seqlist;
            }

            @Override
            protected void done() {
                List<SeqRunI> seq = null;
                try {
                    seq = get();
                } catch (InterruptedException | ExecutionException ex) {
                    Exceptions.printStackTrace(ex);
                }
                if (seq == null || seq.isEmpty()) {
                    System.out.println("closing all");
                    jPanel1.removeAll();
                } else {
                    // Overview
                    for (SeqRunI seqr : seq) {
                        nameseq.setText(seqr.getName());
                        seqid.setText("" + seqr.getExtractId());
                        seqcount.setText("" + NumberFormat.getNumberInstance(Locale.US).format(seqr.getNumSequences()));
                        seqmeth.setText("" + seqr.getSequencingMethod());
                        seqtech.setText("" + seqr.getSequencingTechnology());
                        paired.setText("" + seqr.isPaired());

                        //QC Print
                        try {
                            qccontroll.removeAll();
                            for (QCResultI t : seqr.getMaster().SeqRun().getQC(seqr)) {

                                qccontroll.addTab(t.getName(), QCTopComponent.createChart(t));
                            }
                        } catch (MGXException e) {
                            Exceptions.printStackTrace(e);
                        }

                        //Taxonomie
                        try {
                            List<Map<String, Long>> taxonomie = getTaxonomie(seqr);
                            createPieCharts(taxonomie);
                        } catch (MGXException | InterruptedException | NoSuchElementException e) {
                            Exceptions.printStackTrace(e);

                        }

                        try {
                            Map<String, Map<String, Long>> functional = getFunctional(seqr);
                            createBarChart(functional); 
                        } catch (MGXException | InterruptedException| NoSuchElementException e) {
                            Exceptions.printStackTrace(e);
                        }

                    }

                }
                super.done();
            }

        };
        worker.execute();

    }

    private List<Map<String, Long>> getTaxonomie(SeqRunI seqr) throws MGXException {
        Map<String, Long> kingdomfreq = new HashMap<>();
        Map<String, Long> phylumfreq = new HashMap<>();
        Map<String, Long> classfreq = new HashMap<>();
        Map<String, Long> orderfreq = new HashMap<>();
        Map<String, Long> familyfreq = new HashMap<>();
        Map<String, Long> genusfreq = new HashMap<>();
        Map<String, Long> organismfreq = new HashMap<>();
        List<Map<String, Long>> taxoall = new LinkedList<>();
        List<JobI> joblist = seqr.getMaster().Job().BySeqRun(seqr);

        for (JobI job : joblist) {
            if ((job.getStatus() == JobState.FINISHED && seqr.getMaster().Tool().ByJob(job).getName().equals("MGX taxonomic classification")) || seqr.getMaster().Tool().ByJob(job).getName().equals("Kraken 2")) {

                Iterator<AttributeTypeI> attributeit = seqr.getMaster().AttributeType().byJob(job);
                if (!seqr.getMaster().Attribute().getHierarchy(attributeit.next(), job, seqr).isEmpty()) {
                    
                    TreeI<Long> tmptree = seqr.getMaster().Attribute().getHierarchy(attributeit.next(), job, seqr);
                    Collection<NodeI<Long>> children = tmptree.getLeaves();

                    for (NodeI<Long> activeNode : children) {
                        String genus, family, order, oclass, phylum, kingdom, organism;
                        genus = family = order = oclass = phylum = kingdom = organism = "None";
                        long ocount, gcount, fcount, orcount, ccount, pcount, scount;
                        ocount = gcount = fcount = orcount = ccount = pcount = scount = 0;
                        while (activeNode.getParent() != null) {
                            String atttype = activeNode.getAttribute().getAttributeType().toString();
                            switch (atttype) {
                                case "NCBI_SPECIES":
                                    organism = activeNode.getAttribute().toString();
                                    ocount = activeNode.getContent();
                                case "NCBI_GENUS":
                                    genus = activeNode.getAttribute().toString();
                                    gcount = activeNode.getContent();
                                    break;
                                case "NCBI_FAMILY":
                                    family = activeNode.getAttribute().toString();
                                    fcount = activeNode.getContent();
                                    break;
                                case "NCBI_ORDER":
                                    order = activeNode.getAttribute().toString();
                                    orcount = activeNode.getContent();
                                    break;
                                case "NCBI_CLASS":
                                    oclass = activeNode.getAttribute().toString();
                                    ccount = activeNode.getContent();
                                case "NCBI_PHYLUM":
                                    phylum = activeNode.getAttribute().toString();
                                    pcount = activeNode.getContent();
                                    break;
                                case "NCBI_SUPERKINGDOM":
                                    kingdom = activeNode.getAttribute().toString();
                                    scount = activeNode.getContent();
                                    break;
                                default:
                                    break;
                            }

                            activeNode = activeNode.getParent();

                        }

                        if (kingdomfreq.containsKey(kingdom) == false) {
                            kingdomfreq.put(kingdom, scount);
                        }
                        if (phylumfreq.containsKey(phylum) == false) {
                            phylumfreq.put(phylum, pcount);
                        }
                        if (classfreq.containsKey(oclass) == false) {
                            classfreq.put(oclass, ccount);
                        }
                        if (orderfreq.containsKey(order) == false) {
                            orderfreq.put(order, orcount);
                        }
                        if (familyfreq.containsKey(family) == false) {
                            familyfreq.put(family, fcount);
                        }
                        if (genusfreq.containsKey(genus) == false) {
                            genusfreq.put(genus, gcount);
                        }
                        if (organismfreq.containsKey(organism) == false) {
                            organismfreq.put(organism, ocount);
                        }

                    }

                }

            }

        }

        taxoall.add(kingdomfreq);
        taxoall.add(phylumfreq);
        taxoall.add(classfreq);
        taxoall.add(orderfreq);
        taxoall.add(familyfreq);
        taxoall.add(genusfreq);
        taxoall.add(organismfreq);

        return taxoall;
    }

    private static Color[] colorPie(int value) {
        Color[] piecolors = new Color[value];
        int red = 108;
        int green = 158;
        int blue = 177;
        for (int i = 0; i < value; i++) {
            final Color color = new Color(red, green, blue);
            piecolors[i] = color;
            red = red + 14;
            green = green - 10;
            if (i % 2 == 0) {
                blue = blue - 5;
            } else {
                blue = blue - 6;
            }
            if (i == 10) {
                piecolors[10] = new Color(177, 108, 123);
            }

        }
        return piecolors;
    }

    private void createPieCharts(List<Map<String, Long>> taxonomie) throws MGXException, InterruptedException, NoSuchElementException  {

        Color tooltipcolor = new Color(120, 85, 137);
        Font sumFont = new java.awt.Font("Avenir Next Condensed", 1, 12);

        if (kingdomchart.getSeriesMap().size() > 0) {
            kingdomchart.getSeriesMap().clear();
        }
        
        
        Color[] kingdomcolor = colorPie(taxonomie.get(0).size());

        System.out.println(kingdomcolor.length);
        Map<String, Long> kingdom = getTopTen(taxonomie.get(0));
        kingdomchart.getStyler().setAnnotationType(PieStyler.AnnotationType.Value);
        kingdomchart.getStyler().setAnnotationDistance(1.1);
        kingdomchart.getStyler().setPlotContentSize(.8);
        kingdomchart.getStyler().setSeriesColors(kingdomcolor);
        kingdomchart.getStyler().setToolTipsEnabled(true);
        kingdomchart.getStyler().setToolTipHighlightColor(tooltipcolor);
        kingdomchart.getStyler().setSumFont(sumFont);
        kingdomchart.getStyler().setSumVisible(true);
        kingdom.forEach((k, v) -> kingdomchart.addSeries(k, v));
        kingdompanel.revalidate();
        kingdompanel.repaint();

        if (phylumchart.getSeriesMap().size() > 0) {
            phylumchart.getSeriesMap().clear();
        }

        Map<String, Long> phylum = getTopTen(taxonomie.get(1));
        Color[] color = colorPie(11);

        phylumchart.getStyler().setAnnotationType(PieStyler.AnnotationType.Value);
        phylumchart.getStyler().setAnnotationDistance(1.1);
        phylumchart.getStyler().setPlotContentSize(.8);
        phylumchart.getStyler().setSeriesColors(color);
        phylumchart.getStyler().setToolTipsEnabled(true);
        phylumchart.getStyler().setToolTipHighlightColor(tooltipcolor);
        phylumchart.getStyler().setSumFont(sumFont);
        phylumchart.getStyler().setSumVisible(true);
        phylum.forEach((k, v) -> phylumchart.addSeries(k, v));
        phylumpanel.revalidate();
        phylumpanel.repaint();

        if (classchart.getSeriesMap().size() > 0) {
            classchart.getSeriesMap().clear();
        }
        Map<String, Long> tclass = getTopTen(taxonomie.get(2));
        classchart.getStyler().setAnnotationType(AnnotationType.Value);
        classchart.getStyler().setAnnotationDistance(1.1);
        classchart.getStyler().setPlotContentSize(.8);
        classchart.getStyler().setSeriesColors(color);
        classchart.getStyler().setToolTipsEnabled(true);
        classchart.getStyler().setToolTipHighlightColor(tooltipcolor);
        classchart.getStyler().setSumFont(sumFont);
        classchart.getStyler().setSumVisible(true);
        tclass.forEach((k, v) -> classchart.addSeries(k, v));
        classpanel.revalidate();
        classpanel.repaint();

        if (orderchart.getSeriesMap().size() > 0) {
            orderchart.getSeriesMap().clear();
        }
        Map<String, Long> order = getTopTen(taxonomie.get(3));
        orderchart.getStyler().setAnnotationType(AnnotationType.Value);
        orderchart.getStyler().setAnnotationDistance(1.1);
        orderchart.getStyler().setPlotContentSize(.8);
        orderchart.getStyler().setSeriesColors(color);
        orderchart.getStyler().setToolTipsEnabled(true);
        orderchart.getStyler().setToolTipHighlightColor(tooltipcolor);
        orderchart.getStyler().setSumFont(sumFont);
        orderchart.getStyler().setSumVisible(true);
        order.forEach((k, v) -> orderchart.addSeries(k, v));
        orderpanel.revalidate();
        orderpanel.repaint();

        if (familychart.getSeriesMap().size() > 0) {
            familychart.getSeriesMap().clear();
        }
        Map<String, Long> family = getTopTen(taxonomie.get(4));
        familychart.getStyler().setAnnotationType(AnnotationType.Value);
        familychart.getStyler().setAnnotationDistance(1.1);
        familychart.getStyler().setPlotContentSize(.8);
        familychart.getStyler().setSeriesColors(color);
        familychart.getStyler().setToolTipsEnabled(true);
        familychart.getStyler().setToolTipHighlightColor(tooltipcolor);
        familychart.getStyler().setSumFont(sumFont);
        familychart.getStyler().setSumVisible(true);
        family.forEach((k, v) -> familychart.addSeries(k, v));
        familypanel.revalidate();
        familypanel.repaint();

        if (genuschart.getSeriesMap().size() > 0) {
            genuschart.getSeriesMap().clear();
        }
        Map<String, Long> genus = getTopTen(taxonomie.get(5));
        genuschart.getStyler().setAnnotationType(AnnotationType.Value);
        genuschart.getStyler().setAnnotationDistance(1.1);
        genuschart.getStyler().setPlotContentSize(.8);
        genuschart.getStyler().setSeriesColors(color);
        genuschart.getStyler().setToolTipsEnabled(true);
        genuschart.getStyler().setToolTipHighlightColor(tooltipcolor);
        genuschart.getStyler().setSumFont(sumFont);
        genuschart.getStyler().setSumVisible(true);
        genus.forEach((k, v) -> genuschart.addSeries(k, v));
        genuspanel.revalidate();
        genuspanel.repaint();

        if (organismchart.getSeriesMap().size() > 0) {
            organismchart.getSeriesMap().clear();
        }
        int totalogra = taxonomie.get(6).size();
        Map<String, Long> organism = getTopTen(taxonomie.get(6));
        long sum = organism.values().stream().reduce(0l, Long::sum);
        organism.remove("Others");
        organismchart.setTitle("Top Ten Organism from Organism " + totalogra + " with overall (" + sum + ")");
        organismchart.getStyler().setAnnotationType(AnnotationType.Value);
        organismchart.getStyler().setAnnotationDistance(1.1);
        organismchart.getStyler().setPlotContentSize(.8);
        organismchart.getStyler().setSeriesColors(color);
        organismchart.getStyler().setToolTipsEnabled(true);
        organismchart.getStyler().setToolTipHighlightColor(tooltipcolor);
        organismchart.getStyler().setSumFont(sumFont);
        organismchart.getStyler().setSumVisible(true);
        organism.forEach((k, v) -> organismchart.addSeries(k, v));
        organismpanel.revalidate();
        organismpanel.repaint();

    }

    private Map<String, Long> getTopTen(Map<String, Long> rank) {
        if (rank.containsKey("None")) {
            rank.remove("None");
        }
        Map<String, Long> tmp = rank;
        Map<String, Long> topTen;
        if (tmp.size() > 10) {
            topTen
                    = tmp.entrySet()
                            .stream()
                            .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                            .limit(10)
                            .collect(Collectors.toMap(
                                    Map.Entry::getKey, Map.Entry::getValue, (entry1, entry2) -> entry1, LinkedHashMap::new));
            topTen.keySet().stream().filter((key) -> (rank.containsKey(key))).forEachOrdered((key) -> {
                rank.remove(key);
            });
            long sum = rank.values().stream().reduce(0l, Long::sum);
            topTen.put("Others", sum);
            //System.out.println(topTen.size());
        } else {
            topTen = rank;

        }

        return topTen;
    }

    private static Color[] colorCOG() {
        Color[] cogcolor = new Color[23];
        cogcolor[0] = new Color(194, 175, 88); //A
        cogcolor[1] = new Color(255, 198, 0); //B
        cogcolor[2] = new Color(153, 0, 255); //C
        cogcolor[3] = new Color(153, 255, 0); //D
        cogcolor[4] = new Color(255, 0, 255); //E
        cogcolor[5] = new Color(153, 51, 77); //F
        cogcolor[6] = new Color(128, 86, 66); //G
        cogcolor[7] = new Color(114, 125, 204); //H
        cogcolor[8] = new Color(92, 90, 27); //I
        cogcolor[9] = new Color(255, 0, 0); // J
        cogcolor[10] = new Color(255, 153, 0); // K
        cogcolor[11] = new Color(255, 255, 0); //L
        cogcolor[12] = new Color(158, 201, 40); //M
        cogcolor[13] = new Color(0, 102, 51); //N
        cogcolor[14] = new Color(0, 255, 255); //O
        cogcolor[15] = new Color(0, 153, 255); //P
        cogcolor[16] = new Color(255, 204, 153); //Q
        cogcolor[17] = new Color(255, 153, 153); // R
        cogcolor[18] = new Color(214, 170, 223); //S
        cogcolor[19] = new Color(0, 0, 255); //T
        cogcolor[20] = new Color(51, 204, 153); //U
        cogcolor[21] = new Color(255, 0, 138); //V
        cogcolor[22] = new Color(102, 0, 153); // Z

        return cogcolor;
    }

    private void createBarChart(Map<String, Map<String, Long>> cogdata)  throws MGXException, InterruptedException, NoSuchElementException {
        if(cogdata.isEmpty()){
            cogpanel.setVisible(false);
            funcpanel.setVisible(false);
            return;
        }
        if (cogchart.getSeriesMap().size() > 0 && funcchart.getSeriesMap().size() > 0) {
            cogchart.getSeriesMap().clear();
            funcchart.getSeriesMap().clear();
        }

        Map<String, Long> cog = cogdata.get("COG");
        Map<String, Long> cogfunc = new TreeMap<>(cogdata.get("COG_funccat"));
        Color tooltipcolor = new Color(120, 85, 137);
        Font sumFont = new java.awt.Font("Avenir Next Condensed", 1, 12);
        cogpanel.setVisible(true);
        funcpanel.setVisible(true);
        Color[] color = colorPie(11);
        Map<String, Long> cogtop = getTopTenCOG(cog);
        cogchart.getStyler().setPlotContentSize(.8);
        cogchart.getStyler().setYAxisDecimalPattern("##.###");
        cogchart.getStyler().setSeriesColors(color);
        cogchart.getStyler().setToolTipsEnabled(true);
        cogchart.getStyler().setToolTipHighlightColor(tooltipcolor);
        cogchart.getStyler().setLegendFont(sumFont);
        cogchart.getStyler().setPlotGridLinesVisible(false);
        cogchart.getStyler().setOverlapped(false);
        cogchart.getStyler().setStacked(true);
        cogchart.getStyler().setXAxisLabelRotation(45);
        cogchart.getStyler().setAvailableSpaceFill(0.7);
        List<String> cogkeys = new ArrayList<>(cogtop.keySet());

        List<Long> cogval = new ArrayList<>(cogtop.values());
        List<String> keys = new ArrayList<>();
        cogkeys.stream().map((i) -> i.split(" ")[0]).forEachOrdered((tmp) -> {
            keys.add(tmp);
        });
        System.out.println(keys);

        for (int i = 0; i < 10; i++) {
            double[] val = temporÃ¤reSeries(cogval.get(i),i, keys.size());
            ArrayList<Double> vals = DoubleStream.of( val ).boxed().collect(
            Collectors.toCollection(() -> ( new ArrayList<>() )) );
            cogchart.addSeries(cogkeys.get(i), keys, vals);
        }
        cogpanel.revalidate();
        cogpanel.repaint();

        Color[] colorcog = colorCOG();
        funcchart.getStyler().setYAxisDecimalPattern("##.###");
        funcchart.getStyler().setSeriesColors(colorcog);
        funcchart.getStyler().setToolTipsEnabled(true);
        funcchart.getStyler().setToolTipHighlightColor(tooltipcolor);
        funcchart.getStyler().setLegendFont(sumFont);
        funcchart.getStyler().setPlotGridLinesVisible(false);
        funcchart.getStyler().setOverlapped(false);
        funcchart.getStyler().setStacked(true);
        funcchart.getStyler().setAvailableSpaceFill(0.7);
        List<String> funckeys = new ArrayList<>(cogfunc.keySet());
        List<Long> funcval = new ArrayList<>(cogfunc.values());

        List<String> vtmp = Arrays.asList("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "Z");
        for (int i = 0; i < 23; i++) {
            double[] t = temporÃ¤reSeries(funcval.get(i), i, 23);
            ArrayList<Double> v = DoubleStream.of( t ).boxed().collect(
            Collectors.toCollection(() -> ( new ArrayList<>() )) );
            funcchart.addSeries(funckeys.get(i), vtmp, v);
        }
        funcpanel.revalidate();
        funcpanel.repaint();
        

    }

    private Map<String, Map<String, Long>> getFunctional(SeqRunI seqr) throws MGXException {
        Map<String, Map<String, Long>> cog = new HashMap<>();

        List<JobI> joblist = seqr.getMaster().Job().BySeqRun(seqr);
        for (JobI job : joblist) {
            if (seqr.getMaster().Tool().ByJob(job).getName().equals("COG") && job.getStatus() == JobState.FINISHED) {
                Iterator<AttributeTypeI> attributeit = seqr.getMaster().AttributeType().byJob(job);
                while (attributeit.hasNext()) {
                    Map<String, Long> cog_tmp = new HashMap<>();
                    AttributeTypeI tmp = attributeit.next();
                    String name = tmp.getName();
                    DistributionI<Long> dist = tmp.getMaster().Attribute().getDistribution(tmp, job, seqr);
                    Set<AttributeI> names = dist.keySet();
                    List<Long> nvalues = (List<Long>) dist.values();
                    Object[] tmpn = names.toArray();
                    for (int i = 0; i < tmpn.length; i++) {
                        cog_tmp.put(tmpn[i].toString(), nvalues.get(i));
                    }
                    cog.put(name, cog_tmp);
                }

            }

        }
        return cog;
    }

    private double[] temporÃ¤reSeries(long data, int idx, int value) {
        double[] tmp = new double[value];
        Arrays.fill(tmp, 0);
        tmp[idx] = (double) data;
        return tmp;
    }
   

    private Map<String, Long> getTopTenCOG(Map<String, Long> cog) {
        Map<String, Long> tmp = cog;
        Map<String, Long> topTen = null;
        if (tmp.size() > 10) {
            topTen
                    = tmp.entrySet()
                            .stream()
                            .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                            .limit(10)
                            .collect(Collectors.toMap(
                                    Map.Entry::getKey, Map.Entry::getValue, (entry1, entry2) -> entry1, LinkedHashMap::new));
            topTen.keySet().stream().filter((key) -> (cog.containsKey(key))).forEachOrdered((key) -> {
                cog.remove(key);
            });
        }
        return topTen;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getSource() instanceof SeqRunI && currentSeqRun != null && currentSeqRun.equals(evt.getSource())) {
            if (ModelBaseI.OBJECT_DELETED.equals(evt.getPropertyName())) {
                SeqRunI src = (SeqRunI) evt.getSource();
                src.removePropertyChangeListener(this);
                currentSeqRun = null;
                tabbedpane.removeAll();
            }
        }
    }

    @Override
    public void resultChanged(LookupEvent le) {
        update();
    }
}
